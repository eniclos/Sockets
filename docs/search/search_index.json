{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3 de serveis i Processos","text":""},{"location":"#ut03-programacio-de-socols-2a-part","title":"UT03. Programaci\u00f3 de S\u00f2cols (2a Part)","text":"<p>Teoria Material creat per: Enrique Nicl\u00f3s Camarasa</p> <p>e.nicloscamarasa@edu.gva.es</p> <p>Licencia Reconocimiento \u2013 NoComercial - CompartirIgual (BY-NC-SA): No se permite un uso comercial de la obra original ni de las posibles obras derivadas, la distribuci\u00f3n de las cuales se debe hacer con una licencia igual a la que regula la obra original.</p> <p>\u00cdndex</p> <p>3.1.  INTRODUCCI\u00d3 3.3.3.2  Multicast UDP (User Datagram Protocol) 3.3.3.3  Resoluci\u00f3 de noms DNS 3.3.3.4 TCP (Transmission Control Protocol)</p>"},{"location":"practiques/tasques/","title":"Pr\u00e0ctiques","text":"<p>A continuaci\u00f3 trobaras la llista de tasques optatives per aquest tema.</p> <p>Com s\u2019ha indicat al tema anterior, el teu repositori de tasques de Bitbucket ha d\u2019estar compartit amb el professor via el mail e.nicloscamarasa@edu.gva.es en aquest cas.</p> <p>Per \u00faltim, i de car\u00e0cter general, els programes cal executar-los com a fils per evitar el llan\u00e7ament de m\u00faltiples programes, aleshores el mateix programa inclour\u00e0 els diferents clients i servidor.</p> <p>Qualsevol dubte, podeu consultar-me a les tutories col\u00b7lectives, a l\u2019individual o al f\u00f2rum del tema a la plataforma Aules.</p> <p>Tasca 3.4</p> <p>Realitza un programa a Java (nom del paquet Task3_04_ClonezillaServer) que simule el comportament del ClonezillaServer amb Multicast usant fils d\u2019execuci\u00f3 on: </p> <p>El funcionament de comunicaci\u00f3 ser\u00e0: - El fil servidor Multicast, esperar\u00e0 10 segons abans de procedir a l\u2019enviament de les dades. El que enviar\u00e0 ser\u00e0 una imatge del disc dur que la visualitzarem en percentatges de disc dur enviat i que ho mostrarem per pantalla. En finalitzar l\u2019enviament es mostrar\u00e0 per pantalla eixe fet i procedir\u00e0 al tancament dels sockets,...</p> <p>- Els fils clients Multicast (almenys 3 fils) el que faran ser\u00e0 subscriure\u2019s a la difusi\u00f3 multicast mostrant totes les dades rebudes i informant de la finalitzaci\u00f3 del mateix en arribar al 100%. En acabar enviament, es mostrar\u00e0 per pantalla la finalitzaci\u00f3 de la recepci\u00f3 de dades, la cancel\u00b7laci\u00f3 de la subscripci\u00f3 i tancament dels ports. </p> <p>Simula 3 clients que es connecten en els primers 10 segons previs a enviament del servidor i el tercer client, es connectar\u00e0 al servidor passats ixos 10 segons inicials enviant les dades per el port que consideres.</p> <pre><code>sequenceDiagram\nautonumber\nNote right of ServidorMulticast: Esperant 10 segons\nClient1-&gt;&gt; ServidorMulticast:  Subscrivint-se a IP:224.15.81.2 al port 5000\nServidorMulticast --&gt;&gt; Client1: Enviament: 10% imatge disc dur...\nClient2-&gt;&gt; ServidorMulticast:  Subscrivint-se a IP:224.15.81.2 al port 5000\nServidorMulticast --&gt;&gt; Client1: Enviament: 20% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 20% imatge disc dur...\nClient3-&gt;&gt; ServidorMulticast:  Subscrivint-se a IP:224.15.81.2 al port 5000\nServidorMulticast --&gt;&gt; Client1: Enviament: 20% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 20% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 20% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 30% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 30% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 30% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 40% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 40% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 40% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 50% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 50% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 50% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 60% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 60% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 60% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 70% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 70% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 70% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 80% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 80% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 80% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 90% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 90% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 90% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Enviament: 100% imatge disc dur...\nServidorMulticast --&gt;&gt; Client2: Enviament: 100% imatge disc dur...\nServidorMulticast --&gt;&gt; Client3: Enviament: 100% imatge disc dur...\nServidorMulticast --&gt;&gt; Client1: Finalitzat enviament\nServidorMulticast --&gt;&gt; Client2: Finalitzat enviament\nServidorMulticast --&gt;&gt; Client3: Finalitzat enviament\nClient1-&gt;&gt; ServidorMulticast:  Cancel\u00b7lant subscripci\u00f3\nClient2-&gt;&gt; ServidorMulticast:  Cancel\u00b7lant subscripci\u00f3\nClient3-&gt;&gt; ServidorMulticast:  Cancel\u00b7lant subscripci\u00f3</code></pre> <p>Exemple execuci\u00f3:  </p> SERVIDOR CLIENT 1 CLIENT 2 SERVIDOR MULTICAST esperant 10 segons CLIENT1. Subscrivint-se a IP:224.15.81.2 al port 5000 Enviament: 10% imatge disc dur... CLIENT2. Subscrivint-se a IP:224.15.81.2 al port 5000 Enviament: 20% imatge disc dur... Dades rebudes: 10% imatge disc dur... Enviament: 30% imatge disc dur... Dades rebudes: 20% imatge disc dur... Enviament: 40% imatge disc dur... Dades rebudes: 30% imatge disc dur... Dades rebudes: 30% imatge disc dur... Enviament: 50% imatge disc dur... Dades rebudes: 40% imatge disc dur... Dades rebudes: 40% imatge disc dur... Enviament: 60% imatge disc dur... Dades rebudes: 50% imatge disc dur... Dades rebudes: 50% imatge disc dur... Enviament: 70% imatge disc dur... Dades rebudes: 60% imatge disc dur... Dades rebudes: 60% imatge disc dur... Enviament: 80% imatge disc dur... Dades rebudes: 70% imatge disc dur... Dades rebudes: 70% imatge disc dur... Enviament: 90% imatge disc dur... Dades rebudes: 80% imatge disc dur... Dades rebudes: 80% imatge disc dur... Enviament: 100% imatge disc dur... Dades rebudes: 90% imatge disc dur... Dades rebudes: 90% imatge disc dur... Finalitzat enviament Dades rebudes: 100% imatge disc dur... Dades rebudes: 100% imatge disc dur... Dades rebudes correctament Dades rebudes correctament Cancel\u00b7lant subscripci\u00f3 Cancel\u00b7lant subscripci\u00f3 <p>Tasca 3.5</p> <p>Implementa la versi\u00f3 Client/Servidor on el servidor requerir\u00e0 la validaci\u00f3 d\u2019usuari i contrasenya per a poder accedir (nom del paquet Task3_05_ValidacioTCP).</p> <p>El funcionament del programa ser\u00e0: </p> <ul> <li> <p>El servidor escoltar\u00e0 peticions a un determinat port, per exemple el 9999 i quedar\u00e0 esperant fins que el client \u00e9s valide o fins que passen 30segons. </p> </li> <li> <p>Quan un client vol connectar-se al servidor, enviar\u00e0 un primer missatge en el que s\u2019enviar\u00e0 una paraula que correspondr\u00e0 a un nom d\u2019usuari proporcionat per teclat. </p> </li> <li> <p>El servidor processar\u00e0 l\u2019usuari i contestar\u00e0: </p> <ul> <li>Si l\u2019usuari NO existeix, mostrar\u00e0 per pantalla \u00abUsuari XXXXX NO existeix\u00bb i sol\u00b7licitar\u00e0 al client l\u2019introducci\u00f3 d\u2019un usuari per teclat. </li> <li>Si l\u2019usuari existeix, mostrar\u00e0 per pantalla \u00abUsuari XXXXX existeix\u00bb i sol\u00b7licitar\u00e0 al client l\u2019introducci\u00f3 d\u2019una contrassenya. </li> </ul> </li> <li> <p>El client introduir\u00e0 l\u2019informaci\u00f3 sol\u00b7licitada al punt anterior i l\u2019enviar\u00e0 al servidor el missatge format per \u00abPASSWD contrassenya\u00bb </p> </li> <li>Si les dades son correctes, el servidor contestar\u00e0 al client amb el missatge \u00abUsuari XXXXX connectat correctament\u00bb i mostrar\u00e0 per pantalla \u00abUsuari XXXXX validat correctament\u00bb per\u00f2 si la contrassenya \u00e9s incorrecta, mostrar\u00e0 per pantalla  \u00abUsuari XXXXX no validat, contrassenya incorrecta\u00bb i respondr\u00e0 al client amb el missatge \u00abUsuari XXXXX, login incorrecte\u00bb</li> </ul> <p>Considera que l\u2019unic usuari v\u00e0lid \u00e9s aquell en el que el nom usuari \u00e9s laura i la contrasenya v\u00e0lida \u00e9s l123.*</p> <p>Exemple execuci\u00f3:</p> SERVIDOR TCP CLIENT TCP 1 CLIENT TCP 2 [SERVIDOR] escoltant al port 9999 [CLIENT] Port del servidor: 9999 [CLIENT]Usuari a enviar al servidor: pepe [CLIENT] Port del servidor: 9999 [SERVIDOR]Usuari pepe NO existeix [CLIENT]Usuari a enviar al servidor: laura [SERVIDOR]Usuari laura existeix [CLIENT]Usuari pepe NO existeix [CLIENT]Proporciona un usuari v\u00e0lid:  laura [CLIENT] Usuari laura existeix [SERVIDOR] Usuari laura existeix [CLIENT] Usuari laura existeix [CLIENT]Contrassenya per usuari laura:  l123 [SERVIDOR]Usuari laura validat  correctament [CLIENT]Contrassenya per usuari laura:  l223 [SERVIDOR]Usuari laura no validat,  contrassenya  incorrecta [CLIENT]Usuari laura connectat  correctament [CLIENT]Usuari laura, login incorrecte"},{"location":"teoria/Introduccio/","title":"Introducci\u00f3","text":""},{"location":"teoria/Introduccio/#31-introduccio","title":"3.1.  INTRODUCCI\u00d3","text":"<p>Una vegada ja assolit i ent\u00e9s el funcionament del protocol UDP i de tot el necessari per a la seua utilitzaci\u00f3 a Java, es segueix amb un altre \u00fas particular del mateix com \u00e9s l\u2019enviament de dades en Multicast (difusi\u00f3) el qual permet un \u00fas m\u00e9s eficient del UDP en el sentit de permetre l\u2019enviament com\u00fa de dades.</p> <p>Cada vegada \u00e9s m\u00e9s habitual trobar ferramentes d\u2019streaming que realitzen un enviament de dades continu per la xarxa, en el que un usuari s\u2019adhereix a un canal o mitj\u00e0 en directe que permet l\u2019enviament de l\u2019streaming. Sobre aquest tipus de difusi\u00f3 es va a centrar la primera part. </p>"},{"location":"teoria/MulticastUDP/","title":"Multicast TCP","text":""},{"location":"teoria/MulticastUDP/#3332-multicast-udp-user-datagram-protocol","title":"3.3.3.2  Multicast UDP (User Datagram Protocol)","text":"<p>Les aplicacions que necessiten transmetre informaci\u00f3 a m\u00faltiples dispositius hauran d\u2019escollir el protocol UDP, amb el risc de p\u00e8rdua d\u2019informaci\u00f3 que aix\u00f2 suposa.</p> <p>Adicional als s\u00f2cols amb datagrames en UDP, la classe java.net inclou una classe espec\u00edfica per a fer enviaments en broadcast o difusi\u00f3, en concret permet l\u2019enviament de datagrames a adreces multicast. Aquesta classe \u00e9s MulticastSocket i es basa en l\u2019\u00fas d\u2019adreces multicast.</p> <p>Una adre\u00e7a multicast no obeeix al format t\u00edpic de classes A, B o C on hi ha una part que identifica a la xarxa i altra que identifica al host. Son adreces on les 32 bits identifiquen a una agrupaci\u00f3 d\u2019equips, no a cap equip en particular i, per tant, no son comparables amb les anteriors. </p> <p>Un router, en detectar l\u2019enviament d\u2019informaci\u00f3 dirigida a una adre\u00e7a broadcast, replicar\u00e0 el paquets rebuts a totes les IP associades a l\u2019adre\u00e7a multicast. L\u2019objectiu d\u2019aquest mecanisme \u00e9s reduir el tr\u00e0nsit dins d\u2019una xarxa.</p> <p>Les adreces multicast compren totes les adreces que es troben al rang [224.0.0.0 - 239.255.255.255]. En altres paraules, la caracter\u00edstica principal de les adreces multicast \u00e9s que permeten a dispositius subscriure\u2019s i per tant formar part d\u2019una agrupaci\u00f3 de difusi\u00f3. Tot aquell dispositiu que estiga subscrit a l\u2019adre\u00e7a multicast rebr\u00e0 les dades enviades per difusi\u00f3 a eixa adre\u00e7a.</p> <p>MulticastSocket (API)</p> <p>Abans entrar en particularitats de la classe i de la seua utilitzaci\u00f3, cal dir que, al ser enviament en UDP, els s\u00f2cols multicast usen el DatagramPacket que s\u2019ha vist a la quinzena anterior per a l\u2019enviament  i recepci\u00f3 de paquets del protocol UDP. En altres paraules, l\u2019\u00fas de la classe MulticastSocket \u00e9s molt semblant a la classe DatagramSocket, pel que fa a la recepci\u00f3 i l\u2019enviament de dades perqu\u00e8 ambdos instancien els paquets com a objectes DatagramPacket i fan servir el protocol UDP per a la transmissi\u00f3.</p> <p>L\u2019\u00fas habitual d\u2019enviaments Multicast \u00e9s aquell en qu\u00e8 un servidor disposa de les dades que requereixen els clients i aleshores, en un determinat moment, quan el servidor Multicast realitza l\u2019enviament de les dades, tot aquell client subscrit a l\u2019adre\u00e7a multicast rebr\u00e0 les dades enviades pel servidor. En aquest sentit, el/els clients es limiten a escoltar i processar les dades rebudes.</p> <p>Important destacar que als s\u00f2cols Multicast han de treballar tots en el mateix port de comunicaci\u00f3 independentment de si actuen com a clients o servidors.</p> M\u00e8todes de MulticastSocket Descripci\u00f3 MulticastSocket() MulticastSocket\u200b(int port) MulticastSocket\u200b(SocketAddress bindaddr) Constructors MulticastSocket. Pot incloure un port o no. En cas que l\u2019incloga, es vincula el s\u00f2col a eixe port, en cas contrari, s\u2019assigna un temporal lliure. Es pot assignar a un s\u00f2col en particular. void     joinGroup\u200b(InetAddress mcastaddr) void     joinGroup\u200b(SocketAddress mcastaddr, NetworkInterface netIf) Acci\u00f3 d\u2019unir-se a una adre\u00e7a multicast.  Tamb\u00e9 permet la subscripci\u00f3 de l\u2019adre\u00e7a multicast associada a una interf\u00edcie de xarxa. void     leaveGroup\u200b(InetAddress mcastaddr) void     leaveGroup\u200b(SocketAddress mcastaddr, NetworkInterface netIf) Acci\u00f3 de desunir-se a una adre\u00e7a multicast.  Tamb\u00e9 permet la cancel\u00b7laci\u00f3 de la subscripci\u00f3 de l\u2019adre\u00e7a multicast associada a una interf\u00edcie de xarxa. public void send\u200b(DatagramPacket p) M\u00e8tode heretat de la classe  DatagramSocket per a l\u2019enviament de datagrames public void receive\u200b(DatagramPacket p) M\u00e8tode heretat de la classe  DatagramSocket per a la recepci\u00f3 de datagrames <p>El procediment per l\u2019enviament i la recepci\u00f3 en multicast consisteix a:</p> <ol> <li>Crear un s\u00f2col multicast.  </li> <li>Subscriure el s\u00f2col creat a una adre\u00e7a en multicast.  </li> <li>Efectuar la recepci\u00f3/enviament de dades mitjan\u00e7ant la classe  DatagramPacket ja coneguda.  </li> <li>Cancel\u00b7lar la subscripci\u00f3 del s\u00f2col a l\u2019adre\u00e7a multicast.  </li> <li>Tancar el s\u00f2col multicast.</li> </ol> <p>Qualsevol objecte MulticastSocket podr\u00e0 fer enviaments a tots els dispositius subscrits i rebre tot all\u00f2 que vaja dirigit a l\u2019adre\u00e7a associada.</p> <p>Esquema resum del funcionament general d\u2019una aplicaci\u00f3 Client/Servidor en Multicast:</p> <p></p> Exemple 3.4 <p>Implementa un programa que genere un fil enviador dell missatge \u201cHola m\u00f3n en multicast\u201d en multicast al port 10000 en el que hi haja 4 fils rebedors que processen el missatge i els mostren per pantalla.</p> <p>Main.java<pre><code>package Exemple3_04_Multicast;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Main {\n\n   public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    try {\n        System.out.println(\"Programa en que els fils treballen en Multicast\"\n            + \"\\n on uns envien dades i altres les reben \"\n            + \"\\n visualitzant-les per pantalla\");\n        System.out.println(\"=======================================================\");\n\n        int portToWork = 10000;\n\n        //Creaci\u00f3 d'una adre\u00e7a IP de Multicast\n        InetAddress multicast = null;\n        try {\n            multicast = InetAddress.getByName(\"230.0.0.1\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n\n        Thread getterMulticast = null;\n        //Creaci\u00f3 i llan\u00e7ament de 4 fils rebedors\n        for (int i=0; i&lt;4; i++) {\n            getterMulticast = new Thread(new GetMulticast(portToWork, multicast), \"GetterMulticast\"+(i+1));\n            getterMulticast.start();   \n        }\n\n        //Creaci\u00f3 i llan\u00e7ament del fil enviador\n        Thread senderMulticast = new Thread(new SendMulticast(portToWork, multicast), \"SenderMulticast\");\n        senderMulticast.start();\n\n        getterMulticast.join();\n        senderMulticast.join();\n\n        System.out.println(\"Programa finalitzat\");\n    } catch (InterruptedException e) { // (1)!\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n   }//main\n}//class\n</code></pre> 1.  excepci\u00f3</p> SendMulticast.java<pre><code>package Exemple3_04_Multicast;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\n\npublic class SendMulticast implements Runnable{\n   //Attrib\n   private int port;\n   private InetAddress multicast;\n\n   //---CONSTRUCTOR--------\n   public SendMulticast(int port, InetAddress multicast) {\n       this.port = port;\n       this.multicast = multicast;\n   }\n\n   public void run() {\n       try {                      \n           //Creaci\u00f3 d'un socol multicast\n           MulticastSocket mSocket = new MulticastSocket(port);\n\n           //Subscripci\u00f3 a l'adre\u00e7a Multicast\n           mSocket.joinGroup(multicast);\n\n           //Missatge a enviar\n           String cadenaAenviar = new String (\"***Hola m\u00f3n en Multicast****\");\n           //Visualitzant el missatge a enviar per DatagramPacket\n           System.out.println(\"[\" + Thread.currentThread().getName() + \"] Text a enviar: \" + cadenaAenviar);\n\n           //Conversio de String a bytes[]\n           byte[] missatge = cadenaAenviar.getBytes(\"UTF-8\");\n\n           //Creacio d'un DatagramPacket amb el missatge\n           DatagramPacket datagrama = new DatagramPacket(missatge, missatge.length, multicast, port);\n\n           //Enviament del DatagramPacket\n           System.out.println(\"[\" + Thread.currentThread().getName() + \"] Enviant text...\");\n           mSocket.send(datagrama);\n\n           System.out.println(\"[\" + Thread.currentThread().getName() + \"] Tancant s\u00f2col multicast\");\n           mSocket.leaveGroup(multicast);\n\n           //Tancament del socket\n           if(!mSocket.isClosed())\n               mSocket.close();\n\n       } catch (IOException e) { \n           // TODO Auto-generated catch block\n           e.printStackTrace();\n       }\n   }//run\n}//class\n</code></pre> GetMulticast.java<pre><code>package Exemple3_04_Multicast;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\n\npublic class SendMulticast implements Runnable{\n   //Attrib\n   private int port;\n   private InetAddress multicast;\n\n   //---CONSTRUCTOR--------\n   public SendMulticast(int port, InetAddress multicast) {\n       this.port = port;\n       this.multicast = multicast;\n   }\n\n   public void run() {\n       try {                      \n           //Creaci\u00f3 d'un socol multicast\n           MulticastSocket mSocket = new MulticastSocket(port);\n\n           //Subscripci\u00f3 a l'adre\u00e7a Multicast\n           mSocket.joinGroup(multicast);\n\n           //Missatge a enviar\n           String cadenaAenviar = new String (\"***Hola m\u00f3n en Multicast****\");\n           //Visualitzant el missatge a enviar per DatagramPacket\n           System.out.println(\"[\" + Thread.currentThread().getName() + \"] Text a enviar: \" + cadenaAenviar);\n\n           //Conversio de String a bytes[]\n           byte[] missatge = cadenaAenviar.getBytes(\"UTF-8\");\n\n           //Creacio d'un DatagramPacket amb el missatge\n           DatagramPacket datagrama = new DatagramPacket(missatge, missatge.length, multicast, port);\n\n           //Enviament del DatagramPacket\n           System.out.println(\"[\" + Thread.currentThread().getName() + \"] Enviant text...\");\n           mSocket.send(datagrama);\n\n           System.out.println(\"[\" + Thread.currentThread().getName() + \"] Tancant s\u00f2col multicast\");\n           mSocket.leaveGroup(multicast);\n\n           //Tancament del socket\n           if(!mSocket.isClosed())\n               mSocket.close();\n\n       } catch (IOException e) {\n           // TODO Auto-generated catch block\n           e.printStackTrace();\n       }\n   }//run\n}//class\n</code></pre> Activitat Proposada 3.5 <p>Crea el programa amb el nom de paquet Act3_05_BroadcastIso en que genere un fil servidor encarregat de d\u2019enviar per difusi\u00f3 al port 10000 el percentatge d\u2019una imatge de disc dur que se suposa que t\u00e9 (sols enviar\u00e0 el text del percentatge enviat, p.e. \"50% imatge disc dur...\", no  la imatge). \u000bEl fil servidor esperar\u00e0 5 segons de cortesia per a que es connecten 3 fils clients, i despr\u00e9s enviar\u00e0 el percentatge a tots els fils subscrits. S\u2019enviaran un total de 10 missatges (un per cada 10% de l\u2019imatge enviada) i els fils clients connectats, caldr\u00e0 que mostren per pantalla el text rebut.</p> <p>Exemple:</p> <p>[Servidor Multicast] Escoltant al port 10000...   [Servidor Multicast] Servidor MULTICAST esperant 5 segs       [Client Multicast 1] Client UNINT-SE al multicast IP /224.0.113.0       [Client Multicast 2] Client UNINT-SE al multicast IP /224.0.113.0     [Client Multicast 3] Client UNINT-SE al multicast IP /224.0.113.0 [Servidor Multicast] Enviant paquet: 0% imatge disc dur...     [Client Multicast 1] Client rebut: 0% imatge disc dur\u2026     [Client Multicast 2] Client rebut: 0% imatge disc dur\u2026     [Client Multicast 3] Client rebut: 0% imatge disc dur\u2026 [Servidor Multicast] Enviant paquet: 10% imatge disc dur...     [Client Multicast 1] Client rebut: 10% imatge disc dur\u2026     [Client Multicast 2] Client rebut: 10% imatge disc dur\u2026     [Client Multicast 3] Client rebut: 10% imatge disc dur\u2026 [Servidor Multicast] Enviant paquet: 20% imatge disc dur...     [Client Multicast 1] Client rebut: 20% imatge disc dur\u2026      [Client Multicast 2] Client rebut: 20% imatge disc dur\u2026      [Client Multicast 3] Client rebut: 20% imatge disc dur\u2026 \u2026 [Servidor Multicast] Enviant paquet: 80% imatge disc dur...     [Client Multicast 1] Client rebut: 80% imatge disc dur\u2026      [Client Multicast 2] Client rebut: 80% imatge disc dur\u2026      [Client Multicast 3] Client rebut: 80% imatge disc dur\u2026 [Servidor Multicast] Enviant paquet: 90% imatge disc dur...     [Client Multicast 1] Client rebut: 90% imatge disc dur\u2026      [Client Multicast 2] Client rebut: 90% imatge disc dur\u2026      [Client Multicast 3] Client rebut: 90% imatge disc dur\u2026 [Servidor Multicast] Enviant paquet: 100% imatge disc dur...      [Client Multicast 1] Client rebut: 100% imatge disc dur\u2026      [Client Multicast 2] Client rebut: 100% imatge disc dur\u2026      [Client Multicast 3] Client rebut: 100% imatge disc dur... [Servidor Multicast] Servidor ha finalitzat d\u2019enviar Paquets!    [Client Multicast 1] Client DESUNINT-SE del multicast IP /224.0.113.0 [Client Multicast 2] Client DESUNINT-SE del multicast IP /224.0.113.0 [Client Multicast 3] Client DESUNINT-SE del multicast IP /224.0.113.0[Servidor Multicast] Servidor tancant s\u00f2col Multicast </p>"},{"location":"teoria/ResolucioDNS/","title":"Resoluci\u00f3 DNS","text":""},{"location":"teoria/ResolucioDNS/#3333-resolucio-de-noms-dns","title":"3.3.3.3  Resoluci\u00f3 de noms DNS","text":"<p>Fins ara l\u2019acc\u00e9s als equips s\u2019est\u00e0 fent mitjan\u00e7ant l\u2019adre\u00e7ament IP, que correspon l\u2019identificaci\u00f3 a nivell de xarxa per\u00f2 en una aplicaci\u00f3 \u00e9s molt habitual referir-se als equips no per IP sino per un nom de host, identificaci\u00f3 freq\u00fcent en capa d\u2019aplicaci\u00f3.</p> <p>No obstant aix\u00f2, conforme una aplicaci\u00f3 va baixant a capes inferiors per a fer la transmissi\u00f3 de dades, no ent\u00e9n la identificaci\u00f3 de nom de host i requereix una traducci\u00f3 a una IP. Per exemple, quan s\u2019accedeix mitjan\u00e7ant navegador a https://aules.edu.gva.es, eixa URL \u00e9s un nom que identifica un host per establir una comunicaci\u00f3 a nivell de transport deu identificar-se amb un adre\u00e7ament IP. </p> <p>D\u2019aix\u00f2 se n\u2019encarrega un servei d\u2019internet anomenat servidor de noms de domini, habitualment conegut com a DNS (Domain Name System). Els servidors DNS s\u00f3n serveis gratu\u00efts d\u2019internet, que poden ser interrogats per un nom de domini o subdomini per tal d\u2019aconseguir les adreces IP associades al nom. La xarxa de servidors DNS constitueix una immensa base de dades distribu\u00efda de forma jer\u00e0rquica. La responsabilitat de mantenir les dades actualitzada correspon al propietari dels dominis de manera que el manteniment \u00e9s m\u00ednim.</p> <p>Les aplicacions que admeten noms de dispositius, hauran de consultar el servei DNS per trobar la IP a la qual hauran de direccionar la informaci\u00f3.</p> <p>La classe InetAddress  disposa de m\u00e8todes est\u00e0tics que realitzen la resoluci\u00f3 DNS, \u00e9s a dir, donat un nom de host DNS, permet obtindre l\u2019adre\u00e7a IP associada. Tamb\u00e9 cal dir que disposa de m\u00e8todes que realitzen la resoluci\u00f3 inversa.</p> <p>Els m\u00e8todes son:</p> M\u00e8todes de InetAddress Descripci\u00f3 static InetAddress     getByName(String host) Obt\u00e9 una adre\u00e7a IP a partir de: - Un nom de host usant els serveis de resoluci\u00f3 de noms. P.e. \u201cwww.wikipedia.org\u201d. - Una representaci\u00f3 textual d\u2019una adre\u00e7a IP. P.e. \u201c192.168.1.1\u201d static InetAddress[]     getAllByName(String host) Semblant a l\u2019anterior per\u00f2 m\u00e9s complet, permet retornar un vector amb totes les adreces IP que es poden obtindre usant els serveis de resoluci\u00f3 de noms. String     getHostName() Realitza la resoluci\u00f3 inversa de nom, es a dir, obtindre el nom de host a patir de l\u2019adre\u00e7a IP. String     getCanonicalHostName() Retorna el nom can\u00f2nic o FQDN usant el protocol DNS per a averiguar-ho. static InetAddress     getLocalHost() Retorna l\u2019adre\u00e7a IP del propi host.."},{"location":"teoria/SocketsTCP/","title":"Sockets TCP","text":""},{"location":"teoria/SocketsTCP/#3334-tcp-transmission-control-protocol","title":"3.3.3.4 TCP (Transmission Control Protocol)","text":"<p>\u00c9s un protocol orientat a connexi\u00f3, \u00e9s un protocol m\u00e9s sofisticat i complex que l\u2019UDP pensat per a la intercomunicaci\u00f3 entre dos interlocutors. Aix\u00f2 significa que dos processos que es vulguen comunicar entre s\u00ed, requeriran abans establir una connexi\u00f3.  </p> <p>\u00c9s important destacar que afegeix mecanismes de control sobre el nivell inferior (el protocol IP) que li confereixen una capa de seguretat addicional. \u00c9s per aix\u00f2 pel que el protocol TCP tot i que \u00e9s m\u00e9s lent que el protocol UDP, \u00e9s l\u2019escollit per aplicacions que requerisquen una fiabilitat en la transmissi\u00f3 de les dades.</p> <p>Els paquets de dades enviats per TCP s\u2019anomenen segments i es transmeten en forma de seq\u00fc\u00e8ncia de bytes.</p> <p>La caracter\u00edstica que el defineix i diferencia respecte a UDP \u00e9s la gesti\u00f3 de la transmissi\u00f3, la qual implica:</p> <ul> <li>Realitzar un control d\u2019errors de la informaci\u00f3 enviada de forma que descarta els segments erronis que puguen haver quedat corromputs o duplicats.  </li> <li>Gestionar la retransmissi\u00f3 dels paquets de dades que no han arribat o han arribat en errades for\u00e7ant el reenviament.  </li> <li>Garantitzar l\u2019arribada dels segments ordenada, conforme s\u2019han enviat.  </li> <li>Permetre la comunicaci\u00f3 en els dos sentits, \u00e9s bidireccional, \u00e9s a dir, \u00e9s full-duplex.</li> </ul> <p>Amb el control anterior, es garanteix que qualsevol segment de dades enviat, ser\u00e0 rebut a l\u2019altre extrem de la connexi\u00f3 en l\u2019ordre correcte i lliure de qualsevol error. En eixe sentit, per tal d\u2019assegurar la fiabilitat de les dades, el protocol estableix que per cada segment enviat des d\u2019un o altre dispositiu, el receptor contestar\u00e0 amb un senyal especial de reconeixement (flag ACK) que indique a l\u2019emissor que les dades del segment han arribat amb \u00e8xit. El senyal de reconeixement inclou un valor que identifica la porci\u00f3 de bytes rebuda en segments fent servir el valor del comptador de bytes. </p> <p>D\u2019aquesta manera emissor i receptor poden anar interpretant si la transmissi\u00f3 va tenint \u00e8xit, o si cal fer un nou reenviament d\u2019algun segment, perqu\u00e8 no s\u2019ha rebut el seu senyal de reconeixement (p\u00e8rdua parcial d\u2019alguns segments) o perqu\u00e8 s\u2019ha rebut un reconeixement amb un identificador repetit (\u2019arribada corrupta de dades).</p> <p>En qualsevol cas, \u00e9s el propi protocol el qui s\u2019encarrega de la gesti\u00f3 dels segments alliberant a l\u2019usuari d\u2019aquesta tasca.</p> <p>El protocol TCP mant\u00e9 un di\u00e0leg permanent entre l\u2019emissor i el receptor, en el qual ambd\u00f3s extrems s\u2019informen d\u2019all\u00f2 que van enviant i rebent. La connexi\u00f3 s\u2019inicia amb una petici\u00f3 de connexi\u00f3 i es mant\u00e9 oberta (ambd\u00f3s dispositius s\u2019escolten m\u00fatuament) fins que un dels dos envie un senyal per finalitzar la connexi\u00f3.</p>"},{"location":"teoria/SocketsTCP/#segment","title":"Segment","text":"<p>Per a fer un enviament a TCP, cal adjuntar a les dades una cap\u00e7alera TCP.</p> <p>Tota cap\u00e7alera TCP cal que incloga, entre altres:</p> <ul> <li> <p>Port origen del segment (2 bytes).</p> </li> <li> <p>Port dest\u00ed del segment  (2 bytes).</p> </li> <li> <p>Comptador dades enviades (4 bytes), serveix per a identificar el n\u00famero de segment enviat i per tant l\u2019ordenaci\u00f3 dels diferents segments.</p> </li> <li> <p>Comptador dades rebudes (4 bytes), serveix per a confirmar la correcta arribada de les dades del segment anteriorment enviat.</p> </li> <li> <p>Longitud cap\u00e7alera del segment,  nom\u00e9s la cap\u00e7alera, la longitud de les dades es pot determinar usant l\u2019identificador/comptador de dades enviades. .</p> </li> <li> <p>Control, permet donar informaci\u00f3 extra de les dades de la cap\u00e7alera (flags que regulen la comunicaci\u00f3)  o de l\u2019estat de la transmissi\u00f3.</p> </li> <li> <p>Checksum de la cap\u00e7alera (2bytes), \u00e9s un valor de comprovaci\u00f3 per a realitzar la verificaci\u00f3 de la coher\u00e8ncia de la cap\u00e7alera.</p> </li> </ul> <p></p> <p>Amb el detall de la cap\u00e7alera, i centrant-nos en el camp de Control, s\u2019est\u00e0 en condicions d\u2019explicar el funcionament d\u2019una connexi\u00f3 TCP.</p> <p>L\u2019establiment d\u2019una connexi\u00f3 TCP entre l\u2019emissor i el receptor consisteix en:</p> <ul> <li> <p>Un proc\u00e9s receptor que es quede escoltant sol\u00b7licituds de connexi\u00f3 en un s\u00f2col TCP lligat a un port X concret, </p> </li> <li> <p>Un proc\u00e9s emissor distint, inicia envia la sol\u00b7licitud de connexi\u00f3 (segment amb el flag SYN al camp de Control) a eixe port concret X des d\u2019un port temporal Y.</p> </li> <li> <p>Quan el proc\u00e9s receptor reb la sol\u00b7licitud, l\u2019accepta reservant un port temporal Z per a la comunicaci\u00f3 amb el proc\u00e9s emissor i enviant-li un segment amb els flags SYN (enviament de petici\u00f3 de connexi\u00f3 en sentit contrari) i ACK (confirmaci\u00f3 de la recepci\u00f3 de la petici\u00f3 de connexi\u00f3 de l\u2019emissor) al camp de Control indicant-li el nou port de connexi\u00f3 Z per a la connexi\u00f3.</p> </li> <li> <p>Amb l\u2019enviament d\u2019un tercer segment del proc\u00e9s emissor amb el flag ACK (confirmaci\u00f3 de la recepci\u00f3 de la petici\u00f3 de connexi\u00f3 del receptor) al camp de Control queda establida la connexi\u00f3 entre el port temporal del proc\u00e9s emissor X i el port temporal Z del proc\u00e9s receptor.</p> </li> <li> <p>Aquesta connexi\u00f3 o di\u00e0leg, quedar\u00e0 obert fins que algun dels dos extrems decidisca tancar comunicaci\u00f3 amb l\u2019enviament del flag FIN al camp de Control del segment. Aix\u00ed l\u2019altre extrem, en rebre el flag, sabr\u00e0 que cal tancar connexi\u00f3.</p> </li> </ul> <p></p> <p>Amb el di\u00e0leg comentat anteriorment, s\u2019estableix una connexi\u00f3 bidireccional perqu\u00e8 s\u2019estableix dos canals de comunicaci\u00f3 en cada connexi\u00f3, cada un en un sentit diferent. \u00c9s a dir, es mant\u00e9 un canal de transmissi\u00f3 des del dispositiu A al dispositiu B independentment del canal de transmissi\u00f3 que vaja del dispositu B al dispositiu A. En la pr\u00e0ctica aix\u00f2 implica que cada dispositiu mant\u00e9 un registre del qual envia i rep de forma independent.</p>"},{"location":"teoria/SocketsTCP/#classes-java-per-a-socols-tcp","title":"Classes JAVA per a s\u00f3cols TCP","text":"<p>Els s\u00f2cols orientats a connexi\u00f3 fan servir el protocol TCP.</p> <p>Com s\u2019ha dit amb anterioritat, el protocol TCP defineix que abans de comen\u00e7ar la transmissi\u00f3 de dades cal fer una petici\u00f3 de connexi\u00f3 que l\u2019altra part haur\u00e0 d\u2019acceptar. Una vegada acceptada la connexi\u00f3, en ambd\u00f3s costats es reservar\u00e0 un port de xarxa exclusivament per a la transmissi\u00f3 de dades en qualsevol dels dos sentits. Recordeu que TCP \u00e9s un protocol que defineix una comunicaci\u00f3 full-duplex exclusiva entre dos dispositius.</p> <p>El llenguatge Java t\u00e9 una manera pr\u00f2pia d\u2019implementar aquestes caracter\u00edstiques. Dels dos dispositius a posar en contacte, un d\u2019ells far\u00e0 el paper de servidor esperant la demanda d\u2019algun dispositiu, que jugar\u00e0 el paper de client.</p> <p>Les classes implicades poden veure\u2019s a aquesta jerarquia de classes:</p> <p></p> <p>ServerSocket realitza el proc\u00e9s d\u2019establiment de la connexi\u00f3 a l\u2019estar escoltant fins que un client fa\u00e7a una petici\u00f3 que gestionar\u00e0 amb els m\u00e8todes.</p> <p>Socket representa un extrem de la comunicaci\u00f3, s\u2019usa una vegada ja s\u2019ha establit la connexi\u00f3 per a l\u2019enviament o recepci\u00f3 de dades.</p> <p>SSLServerSocket i SSLSocket ofereixen la mateixa funcionalitat que ServerSocket i Socket respectivament per\u00f2 estan especialitzades en transmetre de forma segura usant un protocol de seguretat anomenat SSL.</p>"},{"location":"teoria/SocketsTCP/#serversocket-api","title":"ServerSocket (API)","text":"<p>Aquesta classe \u00e9s emprada nom\u00e9s per aquella aplicaci\u00f3 que vaja a desenvolupar el rol de servidor a la comunicaci\u00f3, \u00e9s a dir, es crear\u00e0 una \u00fanica inst\u00e0ncia de la classe ServerSocket espec\u00edficament per atendre peticions de  clients a un determinat port que caldr\u00e0 especificar. </p> <p>El m\u00e8tode m\u00e9s important de la classe \u00e9s el m\u00e8tode accept(), el qual fa que el programa quede a l\u2019espera de peticions, quan es reba una petici\u00f3, s\u2019acceptar\u00e0 la connexi\u00f3 i generar\u00e0 una inst\u00e0ncia de tipus Socket per mantenir la comunicaci\u00f3 full-duplex i que correspon al valor retornat pel m\u00e8tode. La creaci\u00f3 d\u2019inst\u00e0ncia del Socket a la banda del servidor es troba automatitzat i s\u2019obt\u00e9 com a retorn del m\u00e8tode accept.</p> <p>Amb el Socket retornat pel m\u00e8tode, queda establida la comunicaci\u00f3 amb el client des d\u2019aquest nou port fins que es finalitze la comunicaci\u00f3.</p> M\u00e8todes de ServerSocket Descripci\u00f3 ServerSocket() ServerSocket\u200b(int port) ServerSocket\u200b(int port, int backlog) ServerSocket\u200b(int port, int backlog, InetAddress bindAddr) Constructors de ServerSocket. Si no s\u2019especifica un port, caldr\u00e0 definir-lo m\u00e9s endavant amb el m\u00e8tode bind() Si no s\u2019indica una IP, es vincula a totes les interf\u00edcies actives. El sencer backlog correspon al tamany m\u00e0xim de la cua de peticions de connexi\u00f3 de clients pendents de ser ateses. Socket    accept() Acci\u00f3 de quedar a l\u2019espera d\u2019una petici\u00f3 de connexi\u00f3 d\u2019un client. Una vegada rebuda, es acceptada  retornant un nou Socket creat especificament per a la comunicaci\u00f3 amb el client. void  bind\u200b(SocketAddress endpoint) void  bind\u200b(SocketAddress endpoint, int backlog) Associa el ServerSocket a un SocketAddress (IP i port) on escoltar peticions. void  close() Tanca el ServerSocket."},{"location":"teoria/SocketsTCP/#socket-api","title":"Socket (API)","text":"<p>La classe Socket representa un extrem de la comunicaci\u00f3 TCP, el qual requereix l\u2019especificaci\u00f3 de l\u2019adre\u00e7a i el port amb el que caldr\u00e0 comunicar-se i disposa de m\u00e8todes per a l\u2019enviament i recepci\u00f3 de dades. Cada extrem de la comunicaci\u00f3 necessita d\u2019una inst\u00e0ncia de la classe Socket.</p> <p>El detall de la classe  Socket pot veure\u2019s al seg\u00fcent quadre resum:</p> M\u00e8todes de Socket Descripci\u00f3 Socket() Socket\u200b(String host, int port) Socket\u200b(InetAddress address, int port) Constructors de Socket. Si no s\u2019especifica un port, caldr\u00e0 definir-lo m\u00e9s endavant amb el m\u00e8tode bind() Si no s\u2019indica una IP, es vincula a totes les interf\u00edcies actives. InputStream     getInputStream() Retorna el InputStream associat al s\u00f2col, des d\u2019aquest es pot rebre informaci\u00f3 enviada des de l\u2019altre extrem de la comunicaci\u00f3. OutputStream    getOutputStream() Retorna el OutputStream associat al s\u00f2col, des d\u2019aquest es pot enviar informaci\u00f3 cap a l\u2019altre extrem de la comunicaci\u00f3. boolean   isInputShutdown() Retorna si el flux  d\u2019entrada continua obert. boolean   isOutputShutdown() Retorna si el flux  d\u2019eixida continua obert. void  shutdownInput() Envia el senyal de finalizaci\u00f3 de la connexi\u00f3 per al flux d\u2019entrada. void  shutdownOutput() Envia el senyal de finalizaci\u00f3 de la connexi\u00f3 per al flux d\u2019eixida. void  bind\u200b(SocketAddress bindpoint) Associa el Socket a un SocketAddress (IP i port). InetAddress   getLocalAddress() Retorna l\u2019adre\u00e7a IP local per al s\u00f2col. InetAddress   getInetAddress() Retorna l\u2019adre\u00e7a IP remota per al s\u00f2col. void  close() Tanca el Socket. <p>Per a la transmissi\u00f3 de dades es fa servir el concepte de flux de dades. Es considera que les dades flueixen de forma cont\u00ednua i seq\u00fcencial des de l\u2019origen fins al dest\u00ed.</p> <p>Els objectes de la classe Socket contenen associats dos fluxos de dades. A trav\u00e9s d\u2019un d\u2019ells es rebran les dades (flux d\u2019entrada) i a trav\u00e9s de l\u2019altre s\u2019enviaran (flux d\u2019eixida). En aplicacions client servidor, el flux d\u2019eixida del servidor equival al flux d\u2019entrada del client i el flux d\u2019entrada del servidor coincidir\u00e0 amb el d\u2019eixida del client.</p> <p>Aquestos fluxos bidireccionals es poden obtindre amb els m\u00e8todes:</p> <ul> <li> <p>getInputStream(), invocat per retornar el flux d\u2019entrada del Socket i poder rebre dades.</p> </li> <li> <p>getOutputStream(), invocat per retornar el flux d\u2019eixida  del Socket i poder enviar dades.</p> </li> </ul> <p>S\u2019usaran els m\u00e8todes propis del fluxos per enviar o rebre dades a trav\u00e9s d\u2019ells. L\u2019enviament a trav\u00e9s del flux de sortida d\u2019un dels s\u00f2cols implicar\u00e0 la recepci\u00f3 de les mateixes dades enviades a trav\u00e9s del flux d\u2019entrada de l\u2019altre s\u00f2col.</p>"},{"location":"teoria/SocketsTCP/#programacio-daplicacions-client-i-servidor-en-tcp","title":"Programaci\u00f3 d\u2019aplicacions Client i Servidor en TCP","text":"<p>Amb tot el comentat anteriorment, ja s\u2019est\u00e0 en disposici\u00f3 de veure el procediment de comunicaci\u00f3 entre dos dispositius usant TCP.</p> <p>Com s\u2019ha vist i es pot deduir, la comunicaci\u00f3 entre els dos dispositius no \u00e9s exactament igual, un dels dos caldr\u00e0 que desenvolupe el rol de Servidor (aquell que espera una petici\u00f3 TCP) i l\u2019altre adopte el rol de Client (aquell que inicia la comunicaci\u00f3 amb una petici\u00f3 TCP).</p> <p>De forma esquem\u00e0tica, el procediment seguit per connectar un client TCP amb un servidor TCP de Java, es pot resumir al seg\u00fcent gr\u00e0fic:</p> <p></p> <p>Els passos del gr\u00e0fic son:</p> <ol> <li> <p>El Client crea un s\u00f2col per demanar connectar-se a l\u2019adre\u00e7a en la qual es troba el servidor i al port on escolta una inst\u00e0ncia de ServerSocket del servidor.</p> </li> <li> <p>El ServerSocket accepta la connexi\u00f3 i crea un s\u00f2col a la part del servidor amb dos canals, un d\u2019entrada i un de sortida.</p> </li> <li> <p>l\u2019 InputStream (flux d\u2019entrada) del s\u00f2col de la part client es troba connectat a l\u2019 OutputStream (flux de sortida) del s\u00f2col de la part servidor i el seu flux d\u2019entrada connecta amb el flux de sortida del s\u00f2col del client. </p> </li> </ol> <p>D\u2019aquesta manera \u00e9s possible la comunicaci\u00f3 en ambdues direccions amb la qualitat exigida pel protocol TCP.</p> <ol> <li>En finalitzar la comunicaci\u00f3 cal tancar els s\u00f2cols en ambd\u00f3s costats.</li> </ol> <p>De forma m\u00e9s global, qualsevol aplicaci\u00f3 TCP, inclou part servidora i part client,  seguir\u00e0 el seg\u00fcent cicle de vida:</p> <p>A continuaci\u00f3 es planteja un exemple que il\u00b7lustra una comunicaci\u00f3 TCP.</p> Exemple 3.5: <p>Implementa un programa al paquet Exemple3_05_HolaAdeuTCP que implemente una breu comunicaci\u00f3 entre un client TCP (Hola.java)  i un servidor TCP (Adeu.java) que aten peticions al  port 15000. El client envia el text \u201cHola\u201d i el servidor li contesta amb el text \u201cAdeu\u201d.</p> <p>Al codi s\u2019observa que s\u2019han emprat fils per implementar la l\u00f2gica del client i servidor TCP</p> Main.java<pre><code>package Exemple3_05_HolaAdeuTCPu;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\n\npublic class Main {\n    static final int serverPort=15000;\n    public static void main(String[] args) {\n\n       try {\n           System.out.println(\"Programa que un client TCP envia la paraula 'Hola' al Servidor\"\n               + \"\\n i el Servidor visualitza el text a m\u00e9s de respondre al Client amb 'Adeu'\"\n               + \"\\n visualitzant-ho tot per pantalla\");\n           System.out.println(\"========================================================================\");\n\n\n           Thread server = new Thread(new Adeu(serverPort),\"servidorADEU\");\n           server.start();\n           Thread.sleep(500);\n\n       Thread client = new Thread(new Hola(InetAddress.getByName(\"127.0.0.1\"), serverPort),\"clientHOLA\");\n           client.start();\n\n           server.join();\n           client.join();\n       }catch (InterruptedException | IOException e) {\n           // TODO Auto-generated catch block\n           e.printStackTrace();\n       }\n   }//main\n}//class\n</code></pre> <p>A la classe Main, es creen els dos fils passant-los com a arguments o b\u00e9 el port on escoltar peticions en el cas del servidor o b\u00e9 el port m\u00e9s la IP del servidor en el cas del Client (Servidor TCP) </p> Adeu.java<pre><code>package Exemple3_05_HolaAdeuTCP;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Adeu implements Runnable{\n   //Atributes\n   private ServerSocket serverSocket;\n   private Socket socketToClient;\n   private int serverPort;\n   DataInputStream fluxIn;\n   DataOutputStream fluxOut;\n\n   //Constructor\n   public Adeu(int portToListen) throws IOException {\n       this.serverPort = portToListen;\n       // ServerSocket\n       this.serverSocket = new ServerSocket(portToListen);\n       socketToClient = null;\n       fluxIn = null;\n       fluxOut = null;\n   }\n\n   public void run() {\n       String cadenaEnviar = \"Adeu\";\n       String data;\n       try {\n\n           System.out.println(\"[\"+Thread.currentThread().getName()+\"]  Esperant peticions al port \" + serverPort + \"...\");\n\n           // Socket esperant peticio\n           socketToClient = serverSocket.accept();\n           System.out.println(\"[\"+Thread.currentThread().getName()+\"]  Atenent al Client al port \"+socketToClient.getPort());\n\n           InputStream in = socketToClient.getInputStream();// Obtenci\u00f3 del flux de LECTURA\n           fluxIn = new DataInputStream(in);                // Conversio a DataInputStream\n           data = fluxIn.readUTF();                        //  lectura del socol Client\n\n           // Mostrant dades rebudes\n           System.out.println(\"[\"+Thread.currentThread().getName()+\"] Dades rebudes al Servidor: \" + data);\n\n           OutputStream out = socketToClient.getOutputStream();// Obtenci\u00f3 del flux d'ESCRIPTURA\n           fluxOut = new DataOutputStream(out);                // Conversio a DataOutputStream\n           System.out.println(\"[\"+Thread.currentThread().getName()+\"] Dades enviades al Client: \" + cadenaEnviar);\n           fluxOut.writeUTF(cadenaEnviar);                         // escriptura al socol Client\n\n           // Tancament del socol amb el Client\n           if (socketToClient != null &amp;&amp; !socketToClient.isClosed()) {\n               //Tancament de flux lectura\n               if (!socketToClient.isInputShutdown()) {\n                   System.out.println(\"[\"+Thread.currentThread().getName()+\"] Tancant flux lectura...\");\n                   socketToClient.shutdownInput();\n               }\n               //Tancament de flux escriptura\n               if (!socketToClient.isOutputShutdown()) {\n                   System.out.println(\"[\"+Thread.currentThread().getName()+\"] Tancant flux escriptura...\");\n                   socketToClient.shutdownOutput();\n               }\n               socketToClient.close();\n           }\n\n           // Tancament del socol Servidor\n           if (!serverSocket.isClosed())\n               System.out.println(\"[\"+Thread.currentThread().getName()+\"] Tancant socol al port \"+ serverPort);\n               serverSocket.close();\n\n           System.out.println(\"[\"+Thread.currentThread().getName()+\"]  Finalitzat\");\n       } catch (IOException e) {\n           // TODO Auto-generated catch block\n           e.printStackTrace();\n       }\n   }//run\n}//class\n</code></pre> <p>Destacar que en finalitzar la comunicaci\u00f3, a m\u00e9s de tancar el s\u00f2col espec\u00edfic per a la conversa amb el client, caldr\u00e0 tamb\u00e9 tancar el s\u00f2col on el servidor escolta peticions abans finalitzar exemple.</p> <p>(Client TCP) Hola.java<pre><code>package Exemple3_05_HolaAdeuTCP;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class Hola implements Runnable{\n    //Atributes\n    private InetAddress IPServer;\n    private Socket socketToServer;\n    private int portToServer;\n    DataInputStream fluxIn;\n    DataOutputStream fluxOut;\n\n\n    //Constructor\n    public Hola(InetAddress IPServer, int portToWrite) throws IOException {\n        this.IPServer = IPServer;\n        this.portToServer = portToWrite;\n        this.socketToServer = new Socket(IPServer, portToServer);\n        fluxIn = null;\n        fluxOut = null;\n    }\n\n    public void run() {\n       String cadenaEnviar = \"Hola\";\n\n        try {\n           // Obtenci\u00f3 del flux d'ESCRIPTURA\n            OutputStream out = socketToServer.getOutputStream();\n            fluxOut = new DataOutputStream(out);    // Conversio a DataOutputStream\n            System.out.println(\"[\"+Thread.currentThread().getName()+\"] Dades enviades al Servidor: \" + cadenaEnviar);\n            fluxOut.writeUTF(cadenaEnviar);             // escriptura al socol del Servidor\n\n           // Obtenci\u00f3 del flux de LECTURA\n           InputStream in = socketToServer.getInputStream();\n           fluxIn = new DataInputStream(in);       // Conversio a DataInputStream\n            System.out.println(\"[\"+Thread.currentThread().getName()+\"] Dades rebudes al Client: \" + fluxIn.readUTF());\n\n           // Tancament del socol amb el Servidor\n           if (socketToServer != null &amp;&amp; !socketToServer.isClosed()) {\n               if (!socketToServer.isInputShutdown()) {\n                   System.out.println(\"[\"+Thread.currentThread().getName()+\"] Tancant flux lectura...\");\n                   socketToServer.shutdownInput();\n                }\n                if (!socketToServer.isOutputShutdown()) {\n                    System.out.println(\"[\"+Thread.currentThread().getName()+\"] Tancant flux escriptura...\");\n                    socketToServer.shutdownOutput();\n                }\n                System.out.println(\"[\"+Thread.currentThread().getName()+\"] Tancant socol\");\n                socketToServer.close();\n\n                System.out.println(\"[\"+Thread.currentThread().getName()+\"]  Finalitzat\");\n           }\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }//run \n}//class \n</code></pre></p> Activitat Proposada 3.6 <p>Realitza un programa al paquet Act3_06_Servidor3Clients que realitze un breu di\u00e0leg orientat a connexi\u00f3 entre un programa servidor i tres clients que intercanvien cadenes d'informaci\u00f3. Cada vegada que es presenta un client, el servidor el saludar\u00e0 enviant-li la frase \"Hola client N\" (on N \u00e9s el n\u00famero de client) a mostrar per pantalla el client. Este servidor sols atendr\u00e0 fins a tres client finalizant la seua execuci\u00f3 despr\u00e9s i mostrant a cada petici\u00f3 el text \"Atenent al client N\".</p> <pre><code>sequenceDiagram\nautonumber\nNote right of Servidor: Esperant connexions al port 11000\nClient1-&gt;&gt; Servidor:  Iniciant comunicaci\u00f3 amb el servidor al port 11000...\n    Servidor --&gt;&gt; Client1: Hola Client1\nClient2-&gt;&gt; Servidor:  Iniciant comunicaci\u00f3 amb el servidor al port 11000...\nServidor --&gt;&gt; Client2: Hola Client2\nClient3-&gt;&gt; Servidor:  Iniciant comunicaci\u00f3 amb el servidor al port 11000...\nServidor --&gt;&gt; Client2: Hola Client3</code></pre> <p>Exemple: </p> SERVIDOR CLIENT 1 CLIENT 2 CLIENT 3 [SERVIDOR]. Esperant peticions al port 11000\u2026 [CLIENT1] Iniciant comunicaci\u00f3 amb el servidor al port 11000\u2026 [SERVIDOR] Atenent al client1. [CLIENT1] Missatge rebut del servidor: Hola client 1 [CLIENT3] Iniciant comunicaci\u00f3 amb el servidor al port 11000\u2026 [SERVIDOR] Atenent al client3. [CLIENT1] Finalitzant  comunicaci\u00f3 amb el servidor\u2026 [CLIENT2] Iniciant comunicaci\u00f3 amb el servidor al port 11000\u2026 [CLIENT3] Missatge rebut del servidor: Hola client 2 [SERVIDOR] Atenent al client2. [CLIENT2] Missatge rebut del servidor: Hola client 3 [CLIENT3] Finalitzant  comunicaci\u00f3 amb el servidor\u2026 [SERVIDOR]. Finalitza amb el tancament del port 11000\u2026 [CLIENT2] Finalitzant  comunicaci\u00f3 amb el servidor\u2026"}]}